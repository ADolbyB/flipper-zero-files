#include <furi.h>
#include <furi_hal.h>

#include <storage/storage.h>
#include <toolbox/stream/stream.h>
#include <toolbox/stream/file_stream.h>

#include <gui/gui.h>
#include <input/input.h>

/* Magic happens here -- this file is generated by fbt.
 * Just set fap_icon_assets in application.fam and #include {APPID}_icons.h */
#include "gpio_controller_icons.h"

#include "app_defines.h"

static void draw_main_view(Canvas* canvas, void* ctx);
static void draw_config_menu_view(Canvas* canvas, void* ctx);

static DrawView draw_view_funcs[] = {
    draw_main_view,
    draw_config_menu_view
};

static void handle_main_input(InputEvent* event, void* ctx);
static void handle_config_menu_input(InputEvent* event, void* ctx);

static HandleInput input_handlers[] = {
    handle_main_input,
    handle_config_menu_input
};

static ViewerState vstate;

static int wiggle[] = {-1,1,-1,1};
static uint32_t wiggle_frame_count = 4;

static ViewElement elements[] = {
    {PIN_5V,     PIN_3V,  true, false,  true,  true, -1,   0,   0, "5V" ,               (Icon*)&I_5v_pin, NULL},
    {PIN_A7,     PIN_SWC, true, false,  true,  true, -1,  14,   0, "PA7",               (Icon*)&I_a7_pin, NULL},
    {PIN_A6,     NONE,    true, false,  true,  true, -1,  28,   0, "PA6",               (Icon*)&I_a6_pin, NULL},
    {PIN_A4,     PIN_SIO, true, false,  true,  true, -1,  42,   0, "PA4",               (Icon*)&I_a4_pin, NULL},
    {PIN_B3,     PIN_TX,  true, false,  true,  true, -1,  56,   0, "PB3",               (Icon*)&I_b3_pin, NULL},
    {PIN_B2,     PIN_RX,  true, false,  true,  true, -1,  70,   0, "PB2",               (Icon*)&I_b2_pin, NULL},
    {PIN_C3,     PIN_C1,  true, false,  true,  true, -1,  84,   0, "PC3",               (Icon*)&I_c3_pin, NULL}, 
    {GEARIC,     PIN_1W,  true,  true,  true, false, -1, 112,   0, "Settings",          (Icon*)&I_gear_unhighlighted, (Icon*)&I_gear_highlighted},
    {PIN_3V,     PIN_5V,  true, false, false,  true, -1,   0,  48, "3.3V",              (Icon*)&I_3v_pin, NULL},
    {PIN_SWC,    PIN_A7,  true, false, false,  true, -1,  14,  48, "Serial Wire Clock", (Icon*)&I_swc_pin, NULL},
    {PIN_SIO,    PIN_A4,  true, false, false,  true, -1,  42,  48, "Serial IO",         (Icon*)&I_sio_pin, NULL},
    {PIN_TX,     PIN_B3,  true, false, false,  true, -1,  56,  48, "UART - Transmit",   (Icon*)&I_tx_pin, NULL},
    {PIN_RX,     PIN_B2,  true, false, false,  true, -1,  70,  48, "UART - Receive",    (Icon*)&I_rx_pin, NULL},
    {PIN_C1,     PIN_C3,  true, false, false,  true, -1,  84,  48, "PC1",               (Icon*)&I_c1_pin, NULL},
    {PIN_C0,     NONE,    true, false, false,  true, -1,  98,  48, "PC0",               (Icon*)&I_c0_pin, NULL},
    {PIN_1W,     GEARIC,  true,  true, false,  true, -1, 112,  48, "1-Wire",            (Icon*)&I_1w_pin, NULL},
    {PIN_GND_08, NONE,   false, false,  true, false, -1,  98,  -1, "GND (Ground)",      (Icon*)&I_gnd_pin, NULL},
    {PIN_GND_11, NONE,   false, false, false, false, -1,  28,  48, "GND (Ground)",      (Icon*)&I_gnd_pin, NULL},
    {PIN_GND_18, NONE,   false, false, false, false, -1, 126,  48, "GND (Ground)",      (Icon*)&I_gnd_pin, NULL},
};

static GPIOPin gpio_pin_config[GPIO_PIN_COUNT];

static int element_count = NONE; // The NONE enum will a value equal to the number of elements defined in enum_view_element

size_t strnlen(const char *str, size_t maxlen) {
    size_t len = 0;
    while (len < maxlen && str[len] != '\0') {
        len++;
    }
    return len;
}

static void init_state()
{
    vstate.selected = PIN_A7;
    vstate.wiggle_frame=-1;
    vstate.view = MAIN_VIEW;
}

static void init_gpio()
{
    int count = 0;
    for(size_t i = 0; i < gpio_pins_count; i++) {
        if(!gpio_pins[i].debug) {
            for(int j = 0; j < element_count; j++) {
                if( strcmp(elements[j].name,gpio_pins[i].name) == 0 )
                {
                        gpio_pin_config[count].element_idx     = j;
                        gpio_pin_config[count].pin             = gpio_pins[i].pin;
                        gpio_pin_config[count].mode            = GpioModeOutputPushPull;
                        gpio_pin_config[count].pull            = GpioPullNo;
                        gpio_pin_config[count].speed           = GpioSpeedVeryHigh;
                        gpio_pin_config[count].value           = 0;
                        gpio_pin_config[count].name            = gpio_pins[i].name;
                        gpio_pin_config[count].unset           = true;
                        gpio_pin_config[count].found           = true;
                        gpio_pin_config[count].input           = false;

                        gpio_pin_config[count].user.mode = GPIO_MODE_UNSET;
                        gpio_pin_config[count].user.value = GPIO_VALUE_FALSE;
                        gpio_pin_config[count].user.gp_idx_input = -1;
                        gpio_pin_config[count].user.changed = false;

                        elements[j].gp_idx   = i;
                        elements[j].editable = true;

                        count++;
                }
            }
        }
    }

    vstate.result = 0;
}

static void update_gpio()
{
    // read from gpio pins
    for(int i = 0; i < GPIO_PIN_COUNT; i++) {
        GPIOPin* gpc = &gpio_pin_config[i];
        if( !gpc->unset )
        {
            if( gpc->mode == GpioModeInput ) {
                gpc->value = furi_hal_gpio_read(gpc->pin) ? 1 : 0;
            }
        }
    }
}

#define TOGGLECOLOR(state, canvas, setting, selected_col, deselected_col) \
    canvas_set_color(canvas, (state == setting) ? selected_col : deselected_col)


const char* gpio_user_mode_strs[] = {"INPUT","INPUT_PULLUP","OUTPUT","UNSET"};
const char* gpio_user_value_strs[] = {"TRUE","FALSE","INPUT"};

static void draw_config_menu_view(Canvas* canvas, void* ctx)
{
    UNUSED(ctx);

    int gp_idx = elements[vstate.selected].gp_idx;
    GPIOPin* gpc = &gpio_pin_config[gp_idx];

    UNUSED(gpc);

    canvas_set_font(canvas, FontSecondary);

    canvas_set_color(canvas, ColorBlack);
    canvas_draw_rframe(canvas, 1, 1, 126, 62, 0);
    
    TOGGLECOLOR(vstate.config_menu_selected, canvas, CONFIG_MENU_MODE, ColorBlack, ColorWhite);
    canvas_draw_box(canvas, 2, 2, 124, 15);

    TOGGLECOLOR(vstate.config_menu_selected, canvas, CONFIG_MENU_MODE, ColorWhite, ColorBlack);
    canvas_draw_str(canvas, 6, 12, "Mode");

    if( gpc->user.mode > 0 ) canvas_draw_str(canvas, 34, 12, "<");

    canvas_draw_str(canvas, 45, 12, gpio_user_mode_strs[gpc->user.mode]);

    if( gpc->user.mode < GPIO_MODE_UNSET ) canvas_draw_str(canvas, 120, 12, ">");

    if( gpc->user.mode == GPIO_MODE_OUTPUT )
    {
        TOGGLECOLOR(vstate.config_menu_selected, canvas, CONFIG_MENU_VALUE, ColorBlack, ColorWhite);
        canvas_draw_box(canvas, 2, 16, 124, 15);

        TOGGLECOLOR(vstate.config_menu_selected, canvas, CONFIG_MENU_VALUE, ColorWhite, ColorBlack);
        canvas_draw_str(canvas, 6, 12 + 16, "Value");

        if( gpc->user.value > 0 ) canvas_draw_str(canvas, 34, 12 + 16, "<");

        canvas_draw_str(canvas, 45, 12 + 16, gpio_user_value_strs[gpc->user.value]);

        if( gpc->user.value < GPIO_VALUE_INPUT ) canvas_draw_str(canvas, 120, 12 + 16, ">");    
    }

}

// TODO: Determine the lowest frame delta we can get away with. 
// TODO: Redraw only what changes.
//       - clear previous (drawn) selected pin
//       - clear newly selected pin

static void draw_main_view(Canvas* canvas, void* ctx)
{
    UNUSED(ctx);

    canvas_clear(canvas);

    size_t current_frame_time = furi_get_tick();
    size_t delta_cycles = (current_frame_time > vstate.prev_frame_time ? current_frame_time - vstate.prev_frame_time : 0);
    size_t delta_time_ms = delta_cycles * 1000 / furi_kernel_get_tick_frequency();

    // delay until desired delta time and recalculate
    if( delta_time_ms < FRAME_TIME )
    {
        furi_delay_ms(FRAME_TIME-delta_time_ms);
        current_frame_time = furi_get_tick();
        delta_cycles = (current_frame_time > vstate.prev_frame_time ? current_frame_time - vstate.prev_frame_time : 0);
        delta_time_ms = delta_cycles * 1000 / furi_kernel_get_tick_frequency();
    }
    
    vstate.elapsed_time += delta_time_ms;
    vstate.prev_frame_time = current_frame_time;

    canvas_set_font(canvas, FontSecondary);

    char hex_string[3];

    // draw values
    for(int i = 0; i < GPIO_PIN_COUNT; i++) {
        if( !gpio_pin_config[i].unset )
        {
            ViewElement e = elements[gpio_pin_config[i].element_idx];

            // draw wire
            if(e.top_row)
            {
                canvas_draw_line(canvas, e.x_pos + 6, e.y_pos + 16, e.x_pos + 6, e.y_pos + 16 + 8);
            }
            else
            {
                canvas_draw_line(canvas, e.x_pos + 6, e.y_pos, e.x_pos + 6, e.y_pos - 8);
            }
            
            if(gpio_pin_config[i].mode == GpioModeAnalog)
            {
                snprintf(hex_string, sizeof(hex_string), "%02X", (int)gpio_pin_config[i].value);
                if(e.top_row)
                {
                    canvas_draw_icon(canvas, e.x_pos - 1, e.y_pos + 20, &I_analog_box);
                    canvas_draw_str(canvas, e.x_pos + 1, e.y_pos + 22 + 7, hex_string);

                }   
                else
                {
                    canvas_draw_icon(canvas, e.x_pos - 1, e.y_pos - 15, &I_analog_box);
                    canvas_draw_str(canvas, e.x_pos + 1, e.y_pos - 6, hex_string);
                }
            }
            else
            {
                const Icon* icon = (int)gpio_pin_config[i].value ? &I_digi_one : &I_digi_zero;
                if(e.top_row)
                {
                    canvas_draw_icon(canvas, e.x_pos + 2, e.y_pos + 20, icon);
                }   
                else
                {
                    canvas_draw_icon(canvas, e.x_pos + 2, e.y_pos - 13, icon);
                }
                
            }
        }
    }

    for(int i = 0; i < element_count; i++)
    {
        ViewElement e = elements[i];
        int x = e.x_pos;
        int y = e.y_pos + (e.top_row && e.pull_out ? -3 : 0);
        Icon* icon = e.icon;

        if( vstate.selected == i )
        {
            if( e.pull_out )
            {
                y += e.top_row ? 3 : -3;
            }
            if( e.selected_icon != NULL )
            {
                icon = e.selected_icon;
            }

            if(vstate.wiggle_frame >= 0)
            {
                x += wiggle[vstate.wiggle_frame];

                if(vstate.elapsed_time >= ANIMATE_FRAME_TIME_MS)
                {
                    vstate.wiggle_frame++;
                    if ((unsigned int)(vstate.wiggle_frame) >= wiggle_frame_count)
                    {
                        vstate.wiggle_frame = -1;
                    }
                    vstate.elapsed_time = 0;
                }
            }
        }

        canvas_draw_icon(canvas, x, y, icon);
    }

    // draw arrows
    for(int i = 0; i < GPIO_PIN_COUNT; i++) {
        if( !gpio_pin_config[i].unset )
        {
            ViewElement e = elements[gpio_pin_config[i].element_idx];

            bool selected = vstate.selected == gpio_pin_config[i].element_idx;

            // draw arrow
            if(e.top_row)
            {   
                int offset = selected ? 3 : 0;
                const Icon* arrow_icon = gpio_pin_config[i].input ? &I_arrow_up : &I_arrow_down;
                canvas_draw_icon(canvas, e.x_pos + 3, e.y_pos + 8 + offset, arrow_icon);
            }   
            else
            {
                int offset = selected ? 0 : 3;
                const Icon* arrow_icon = gpio_pin_config[i].input ? &I_arrow_down : &I_arrow_up;
                canvas_draw_icon(canvas, e.x_pos + 3, e.y_pos + -1 + offset, arrow_icon);
            }
        }
    }

    

    canvas_set_font(canvas, FontSecondary);
    canvas_draw_str(canvas, 0, 42, elements[vstate.selected].name);
}

static void handle_main_input(InputEvent* event, void* ctx) {
    if( vstate.wiggle_frame < 0 )
    {
        furi_assert(ctx);
        FuriMessageQueue* event_queue = ctx;

        // place in queue to handle backing out of app
        furi_message_queue_put(event_queue, event, FuriWaitForever);

        if( (event->type == InputTypePress || event->type == InputTypeRelease) && event->key == InputKeyOk )
        {
            if( event->type == InputTypePress && elements[vstate.selected].gp_idx < 0 )
            {
                vstate.wiggle_frame = 0;
                vstate.elapsed_time = 0;
            }
            else if( elements[vstate.selected].gp_idx >= 0 && (event->type == InputTypePress || event->type == InputTypeRelease) )
            {
                int gp_idx = elements[vstate.selected].gp_idx;
                gpio_pin_config[gp_idx].user.prev_mode = gpio_pin_config[gp_idx].user.mode;

                vstate.view = CONFIG_MENU_VIEW;
                vstate.config_menu_selected = CONFIG_MENU_MODE;
            }
        }
        else if(event->type == InputTypePress || event->type == InputTypeRepeat) {
            switch(event->key) {
            case InputKeyLeft:
                vstate.selected--;
                if(vstate.selected == GEARIC) vstate.selected = PIN_1W;
                else if(vstate.selected < 0) vstate.selected = GEARIC;
                break;
            case InputKeyRight:
                if(vstate.selected <= GEARIC)
                {
                    vstate.selected++;
                    vstate.selected = vstate.selected > GEARIC ? PIN_5V : vstate.selected;
                }
                else
                {
                    vstate.selected++;
                    vstate.selected = vstate.selected > PIN_1W ? PIN_3V : vstate.selected;
                }
                break;
            case InputKeyUp:
            case InputKeyDown:
                if (elements[vstate.selected].opposite != NONE) vstate.selected = elements[vstate.selected].opposite;
                break;
            default:
                break;
            }
        }
    }
}

static void set_GPIO_pin_via_user(int gp_idx)
{
    GPIOPin* gpc = &gpio_pin_config[gp_idx];

    if(gpc->user.changed)
    {
        // update attributes
        switch(gpc->user.mode)
        {
        case GPIO_MODE_INPUT:
            gpc->mode = GpioModeInput;
            gpc->pull = GpioPullNo;
            gpc->input = true;
            break;
        case GPIO_MODE_INPUT_PULLUP:
            gpc->mode = GpioModeInput;
            gpc->pull = GpioPullUp;
            gpc->input = true;
            break;
        case GPIO_MODE_OUTPUT:
            gpc->mode = GpioModeOutputPushPull;
            gpc->pull = GpioPullNo;
            gpc->input = false;
            break;
        default:
            break;
        }

        switch(gpc->user.value)
        {
        case GPIO_VALUE_TRUE:
            gpc->value = (double)1.0;
            break;
        case GPIO_VALUE_FALSE:
        case GPIO_VALUE_INPUT:
        case GPIO_VALUE_NONE:
            gpc->value = (double)0.0;
            break;
        default:
            break;
        }

        furi_hal_gpio_write(gpc->pin, gpc->value != (double)0.0 ? true : false);
        if( gpc->user.mode != gpc->user.prev_mode) {
            furi_hal_gpio_init(gpc->pin, gpc->mode, gpc->pull, gpc->speed);
            gpc->unset = false;
        }
        
        gpc->user.changed = false;
    }
}

static void handle_config_menu_input(InputEvent* event, void* ctx) {
    UNUSED(ctx);

    int gp_idx = elements[vstate.selected].gp_idx;
    GPIOPin* gpc = &gpio_pin_config[gp_idx];

    if(event->type == InputTypePress || event->type == InputTypeRepeat) {
        switch(event->key) {
        case InputKeyLeft:
            switch(vstate.config_menu_selected)
            {
            case CONFIG_MENU_MODE:
                if(gpc->user.mode > 0) {
                    gpc->user.mode--;
                    gpc->user.changed = true;
                }
                break;
            case CONFIG_MENU_VALUE:
                if(gpc->user.value > 0) {
                    gpc->user.value--;
                    gpc->user.changed = true;
                }
                break;
            case CONFIG_MENU_INPUT:
                break;
            default:
                break;
            }
            break;
        case InputKeyRight:
            switch(vstate.config_menu_selected)
            {
            case CONFIG_MENU_MODE:
                if(gpc->user.mode < GPIO_MODE_UNSET) {
                    gpc->user.mode++;
                    gpc->user.changed = true;
                }
                break;
            case CONFIG_MENU_VALUE:
                if(gpc->user.value < GPIO_VALUE_FALSE) {
                    gpc->user.value++;
                    gpc->user.changed = true;
                }
                break;
            case CONFIG_MENU_INPUT:
                break;
            default:
                break;
            }
            break;
        case InputKeyUp:
            if(gpc->user.mode == GPIO_MODE_OUTPUT )
            { 
                if( vstate.config_menu_selected == 0 ) vstate.config_menu_selected = CONFIG_MENU_VALUE;
                else vstate.config_menu_selected--;
            }
            break;
        case InputKeyDown:
            if(gpc->user.mode == GPIO_MODE_OUTPUT )
            {
                if( vstate.config_menu_selected == CONFIG_MENU_VALUE ) vstate.config_menu_selected = 0;
                else vstate.config_menu_selected++;
            }
            break;
        case InputKeyBack:
            
            // Set new pin configuration
            set_GPIO_pin_via_user(gp_idx);

            vstate.view = MAIN_VIEW;

            break;
        default:
            break;
        }
    }
}

static void app_draw_callback(Canvas* canvas, void* ctx) {
    draw_view_funcs[vstate.view](canvas,ctx);
}

static void app_input_callback(InputEvent* input_event, void* ctx) {
    input_handlers[vstate.view](input_event,ctx);
}

int32_t gpio_controller_main(void* p) {
    UNUSED(p);
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    // Configure view port
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, app_draw_callback, view_port);
    view_port_input_callback_set(view_port, app_input_callback, event_queue);

    // Register view port in GUI
    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    InputEvent event;

    init_state();
    init_gpio();

    vstate.prev_frame_time = furi_get_tick();
    vstate.elapsed_time = 0;

    bool running = true;
    while(running) {
        if(furi_message_queue_get(event_queue, &event, 100) == FuriStatusOk) {

            if(event.type == InputTypePress || event.type == InputTypeRepeat) {
                switch(event.key) {
                case InputKeyBack:
                    running = false;
                    break;
                default:
                    break;
                }
            }
        }

        update_gpio();
        view_port_update(view_port);
    }

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    furi_record_close(RECORD_GUI);

    return 0;
}
